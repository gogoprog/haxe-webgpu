// Generated by Haxe 4.3.1
(function ($global) { "use strict";
var Demo = function() { };
Demo.main = function() {
	var vertexShader = "\n        struct VSOutput {\n            @builtin(position) position: vec4<f32>,\n                     @location(0) color: vec4<f32>\n        };\n\n        const positions = array<vec2<f32>, 3>(\n                              vec2(0.0,  0.5),\n                              vec2(-0.5, -0.5),\n                              vec2(0.5, -0.5)\n                          );\n\n        const colors = array<vec3<f32>, 3>(\n                           vec3(0.0, 1.0, 1.0),\n                           vec3(0.0, 0.0, 1.0),\n                           vec3(1.0, 0.0, 1.0)\n                       );\n\n        @vertex\n        fn main(@builtin(vertex_index) vertexIndex: u32) -> VSOutput {\n            return VSOutput(\n                vec4(positions[vertexIndex], 0.0, 1.0),\n                vec4(colors[vertexIndex], 1.0)\n            );\n        }";
	var fragmentShader = "\n                             @fragment\n        fn main(@location(0) color: vec4<f32>) -> @location(0) vec4<f32> {\n            return color;\n        }\n        ";
	var render = function(gpu,canvasContext) {
		gpu.requestAdapter().then(function(adapter) {
			adapter.requestDevice().then(function(device) {
				console.log("test/Demo.hx:39:",device);
				var format = gpu.getPreferredCanvasFormat();
				var commandEncoder = device.createCommandEncoder();
				var pipeline = device.createRenderPipeline({ layout : "auto", vertex : { module : device.createShaderModule({ code : vertexShader}), entryPoint : "main"}, fragment : { module : device.createShaderModule({ code : fragmentShader}), entryPoint : "main", targets : [{ format : format}]}, primitive : { topology : "triangle-list"}});
				canvasContext.configure({ device : device, format : format, alphaMode : "premultiplied"});
				var passEncoder = commandEncoder.beginRenderPass({ colorAttachments : [{ view : canvasContext.getCurrentTexture().createView(), clearValue : { r : 0, g : 0.05, b : 0, a : 1}, loadOp : "clear", storeOp : "store"}]});
				passEncoder.setPipeline(pipeline);
				passEncoder.draw(3,1,0,0);
				passEncoder.end();
				device.queue.submit([commandEncoder.finish()]);
			});
		});
	};
	if(navigator.gpu) {
		var canvas = window.document.getElementById("canvas");
		render(navigator.gpu,canvas.getContext("webgpu"));
	} else {
		window.alert("WebGPU is not supported or is not enabled, see https://webgpu.io");
	}
};
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
};
Demo.main();
})({});
